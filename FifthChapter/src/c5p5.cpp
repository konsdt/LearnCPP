#include <iostream>


// 5.5 Comma and conditional separators
// "Comma Operator"
// Allows to evaluate mutltiple expressions wherever a single expression is allowed
// it evaluates the left and then the right operand and returns the result of
// the right operand
// /Best practice/: avoid comma operand since in almost every case it would be
// better written in seperate statements.
// it has the absolute lowest precedence!
// "Conditional Operator"
// syntax: c ? x : y meaning: if c is nonzero(true) evaluate x otherwise evaluate y
// can be used in places that if/else statements can not be
// variables defined inside an if/else statement die at the end of the statement
// /Best practice/: Only use conditional operator for simple conditionals where
// you use the result and where it enhances readability.
// 5.6 Relational Operators and floating point comparison
// Extremelly straight forward to use when comparing integers.
// /Best practice/: When using bools, do not add unnecessary == or != conditions.
// It makes the harder to read without offering any additional value.
// Do not use these operators on floating point numbers because of precision
// problems.
// You can always write a function that specifies the allowed difference for
// two floats that are supposed to be compared. Order of magnituded is really
// important.
// e.g. 1.000001 is the same as 1.0000001 but then also 0.000001 is the same as
// 0.0000001 which does not seem as reasonable.
// One suggestion that should work for most cases is:
bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)
{
    // Check if the numbers are really close -- needed when comparing numbers near zero.
    double diff{ std::abs(a - b) };
    if (diff <= absEpsilon)
        return true;

    // Otherwise fall back to Knuth's algorithm
    return (diff <= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
}

// 5.7 Logical Operators
// 
// Logical NOT: !  alternative: not
// Logical AND: && alternative: and
// Logical  OR: || alternative: or
//
// /Best practice/: If logical NOT is intended to operate on the result of other
// operators, the other operators need to be enclosed by paranthesis, because the
// logical Operator has an extremely high precedence.
// Short circuit evaluation: can cause logical OR and logical AND failures since
// if the first evaluation criteria already terminates the if clause
// the other statements are not even evaluated. e.g.: if (x == 1 && ++y == 2)
// if x != 1 then y is never incremented
// -> they are an exception of the rule that operands may evaluate in any order,
// they will always evaluate from left to right.
// /Best practice/: when mixing ANDs and ORs always paranthesize them to make
// sure they evaluate in the intended order.
// De Morgan's law: When distributing logical NOTs the logical ORs or ANDs need to
// be flipped to logical ANDs and ORs respectively.
// !(x && y) <=> !x || !y
// !(x || <) <=> !x && !y
// Logical XOR is not provided since it can't be short circuited
// but it can easily be generated by testing if two bools are not equal:
// if (a != b) only if either a or b are true but not both are true!
// The bools need of course be in integer form.
// :or use static cast: if (static_cast<bool>(a) != static_cast<bool>(b))

int main()
{
    int x{ 1 };
    int y{ 2 };
    int larger{ };  
    std::cout << (++x, ++y);
   
    // if (x > y)
    //     larger = x;
    // else
    //     larger = y;
    // above can be written in one line:
    larger = ((x > y) ? x : y);
    //should always be paranthesized to avoid precedence conflicts with other 
    //operators

    std::cout << larger;

    return 0;
}
